29p
프로세스에 쓰레드 개념이 도입되면서 cpu에 스케쥴링 되는것은 쓰레드이다.
쓰레드는 유저레벨 쓰레드, 커널레벨 쓰레드로 나뉘고
유저레벨 쓰레드를 커널레벨 쓰레드로 매핑하는 것 중에서 1:n m:m이 있었다.
이것들은 유저레벨 쓰레드를 LWP라는 곳에 스케쥴링(매핑)했었다.
이 수준을 PCS라고 한다. 이떄 적용되는 우선순위를 프로그래머가 직접 세팅할수있다.
실제 쓰레드가 cpu상에서 실행되려면 커널레벨 쓰레드가 할당되어야한다.

30p
SCS는 어느 커널레벨 쓰레드를 스케쥴링 할것인가를 결정할것인가를 말한다.

31p
LWP에 대한 설명이다.
매핑 위계구조를 나타낸다.

32p
PTHREAD에는 process 레벨 스케쥴링이냐 system 레벨스케쥴링이냐를 선택할 수 있다.
즉 PCS SCS를 선택할 수 있는 API를 제공한다는 말이다.
리눅스나 맥은 SCS만 허용을 해준다.

33p
getscope는 경쟁 범위(PCS, SCS)의 정책이 무슨 정책인지 알 수 있는 api

34p
setscope는 경쟁 범위의 정책을 세팅하는 api

35p
지금까지는 프로세서가 하나일 경우만 살펴 보았다.
프로세서가 여러개일 경우에는 스케쥴링이 더 복잡해 진다.
Homogeneous processors
cpu가 여러개일 경우에도 기본 가정은 프로세서 하나하나가 동일한 기능 성능을
가진다고 한다. 
Asymmetric multiprocessing
이것은 프로세서가 여러개지만 오직 하나의 프로세서만 데이터에 접근을 하는것이다.
다른 프로세서들은 동일한 level로 스케쥴링이 되어 동작하는게 아니라, 어떤 한 프로세서의
데이터를 주고 이 하나의 프로세서에 의해 나머지 프로세서의 동작이 결정이 되는것이다.
멀티프로세싱 스케쥴링을 고려할게 별로 없다.
symmetric multiprocessing(SMP)
4개의 프로세서가 있다면 이 4개의 프로세서가 동일하게 데이터에 대한 권한을 가진다
그래서 멀티프로세싱 스케쥴링이 중요하게 된다. 이개념이 가장 일반적이고 널리 사용된다.
Processor affinity(프로세서 친화성)
어떤 프로그램은 특정 프로세서에 친화성을 가진다는 말인데, 어떤 프로세스는 특정
코어에 할당이 되어서 동작이 되면 성능이 좋게 나온다고 보는 것이다. 여기서
soft affintiy와 hard affinity가 있다.
soft affintiy를 보명 os가 동일한 처리기(특정 코어)에서 프로세스를 실행시키려 노력하지만
보장은 하지 않는것이고 hard affintiy는 시스템 호출 단계에서 이미 자신이 실행될
코어의 집합이 정해지는 것이다.

36p
멀티코어를 가지는 시스템에 메모리의 구조 자체가 프로세서의 친화성에 영향을 줄 수
있다. NUMA(not uniform memory access) 아키텍처를 보자. 그림에서 코어는 두개이다.
두개의 코어중에서 왼쪽에 있는 코어는 자기자신의 메모리를 엑세스 할때는 빨리
엑세스 가능하지만 오른쪽에 있는 메모리를 엑세스 할때는 당연히 느리다. 그래서
메모리 엑세스할때 균일하지 않다는 뜻으로 NUMA라고 한다.
왼쪽의 경우 어떤 프로그램이 자신의 로컬 메모리를 많이 엑세스 한다라고 하면
그 프로세서는 당연히 왼쪽 프로세서에 할당이 되는것이 좋다. 
스케쥴링은 따라서 아키텍처에 영향을 받을 수 밖에 없다.

37p
multiprocessor scheduling(멀티코어 프로세서 아님 코어만 두개라는게 아니라 그냥
전체 프로세서가 두개라는 뜻)의 또 다른 목적은 
Load Balancing (부하를 균등화) 이다.
SMP(Symmetric multi processor)상에서는 모든 cpu코어가 동일하게 부하를 가지고
실행이 되게끔 해서 전체의 효율성을 높이는것이 스케쥴링의 목적이 된다.
부하 균등화를 위해서 두가지 방식이 있다.
첫번째로 push migration은 어떤 task laod를 다른 프로세서에 밀어주는것
이것은 특정 task가 주기적으로 각 프로세서의 부하를 체크한다. 불균형 상태라고
판단이 내려지면 과부하된 task를 덜 바쁜 프로세서로 이 task를 푸쉬해준다.
두번째로 pull migration은 어떤 task load를 다른 프로세서에서 당겨오는것인데
프로세서 입장에서 자기가 좀 쉬고있다고 생각하면 바쁜 프로세서의 대기상태 task를
당겨와서 자기가 실행 하는 것을 말한다.

38p
Multicore Processor 상의 스케쥴링 관련 이슈들을 살펴보자.
최근의 트렌드느 멀티프로세서가 아니라 멀티코어임
훨씬 빠르고 소비전력도 적다.
이런 경우의 스케쥴링은 더 복잡해진다.
먼저 memory stall 이라는 개념을 살펴보자. 이것은 다중 코어 프로세서 상에서
특정 프로세스가 메모리에 접근한다고 하자(하나의 코어가 메모리에 접근할때). 
이때 메모리상에 있는 데이터를 얻을때 까지 메모리는 지연시간이 있고 여러가지 이유로
바로 엑세스 못하고 지연이 생긴다. 이걸 memory stall이라고한다. 캐시의 영향을 많이 받음
어떤 코어상에서 프로세스가 동작 되고 있는데 그것이 특정 주소에있는 데이터에 엑세스
하려한다. 그래서 자신의 코어안에 있는 캐시에 접근 했는데 그 데이터가 없다. 그러면다시
메모리로 엑세스를 한다. 그래서 캐시미스가 발생할때 memory stall이 발생한다고 한다.
특히 쓰레드에 대한 스케쥴링을 할때는 이 memory stall 현상을 적극 이용을 해서
전체적은 multithread 스케쥴링을 수행 할 수 있다.

39p
아래쪽 그림은 단일 코어라고 보면되고, 스케쥴링을 통해서 두개의 쓰레드를 할당했다.
스레드0이 memory stall이 발생할때 스레드1이 계산을 한다 이런식으로 전체적으로
단일 코어의 계산 효율성을 높일 수 있다. 즉 두개의 스레드를 번갈아 가면서 수행하게
되면 이 memory stall에 의해 발생되는 효과를 역으로 이용해서 cpu의 활용도를 높인것

40p
실시간 cpu 스케쥴링 개념에 대해 보자.
soft real-time system은 중요한 프로세스가 특정시간까지 스케쥴링이 되는것을 보장 못함
=> 어떤 중요한 프로세스는 다른 프로세스보다 우선순위가 주어진다는 것이지,
반드시 어떤 특정 시점까지 스케쥴링이 되어서 실행이 되어야 한다라는 것을
보장할 필요는 없다.
hard real-time system은 태스크가 반드시 특정시간까지 서비스가 되는것을 보장 하는것.
=> 언제까지 이 프로세스는 반드시 실행이 끝나야 한다고 보장해야한다.
Event Latency는 이벤트의 지연시간, 이벤트가 발생이 되어서 그 이벤트에 대한
서비스가 수행될때 까지의 시간이다. 이벤트가 발생이 되어서 real time 시스템이 그 이벤트에
반응을 하는데 걸리는 시간을 말한다.
실시간 시스템의 성능에 영향을 주는 두가지가 있다.
1. interrupt 지연시간 = 인터럽트가 발생해서 실행될때까지 걸리는 시간
2. Dispatch 지연시간 = 현재의 프로세스가 block 되고 다른 프로세스가 시작할때 가지
걸리는 시간

41p
그림을 보면 Interrupt Latency가 명확하다. 인터럽트 도착부터 인터럽트 실행시간 까지 걸린
시간이다. 커널 작업을할때 인터럽트를 disable시키는데 이러면 인터럽트 지연시간이
상당히 길어 질 수 있다.

42p
Dispatch 지연시간은 전에 말한것 처럼 현재 프로세스를 stop하고 다른 프로세스를 시작하는데 .3걸리는 시간을 말한다. 실시간 os에서는 이 dispatch 지연시간을 최소화 할수록 좋다.
Dispatcher의 정의를 다시 알아보자. 스케쥴러가 이 프로세스를 실행 해라 라고 하면 그 프로세스를
실제 실행을 할 수 있게끔 세팅해주는 모듈을 말한다. 그래서 Dispatcher는 최대한 빨리 
기존의 프로세스를 blocking하고 새로운 프로세스를 빨리 실행시켜야 한다.
이 dispatch 지연시간에는 conflict phase라는 것이 있다. 이것은 스케쥴러가 특정 프로세스를
실행해라고 dispatcher에게 명령했다. 그러면 dispatcher는 이 특정 프로세스를 실행 시켜줘야한다.
그런데 커널에는 이전에 다른 프로세스가 실행중이다. 그걸 없애야한다. 이 동작이 하나 필요하고
두번째로 기존의 쫓겨난 프로세스가 사용하고 있는 리소스들을 새로운 프로세스가 사용할수
있게끔 만들어 줘야한다. 이 두 동작을 conflict phase라고 한다. 그리고 dispatch phase가 실행된다

44p
Dispatch Latency에 대해 상세하게 다른관점으로 설명한다.
앞에 말한 conflict를 여기서는 wakeup이라고 말하고 있다. 내용은 똑같다