42p
이제 프로세스끼리 메시지를 직접 전송하는 방법에 대하여 알아보자.
이전에는 두 프로세스가 동일하게 바라보는 공유 메모리공간이 있어서 두프로세스간
통신이 이루어졌다.

43p
하지만 메시지 패싱 방법은 두개의 프로세스가 각각의 주소공간을 가지고 있다.
그래서 각각 메시지를 보내고 받는 형태가 만들어 져야한다.

44p
physical 수준이아닌 논리적 수준에서 커뮤니 케이션을 바라본다.

45p
Direct communication
send(P, message)라고 하면 프로세스 P에 메시지를 보낸다.
receive(Q, message)Q로부터 message를 받는다.
누구에게 보내느냐 누구로부터 오느냐에 대한 정보가 있다 와 같은 직접적인 정보가 있다.

46p
Indirect communication
직접적인 정보가 없이 제 3의 매개체를 이용한다.
대표적인 개념이 메일박스(port)라는 개념이 있다.
메일박스로 메시지를 보내고 수신측으로부터는 메일박스로 부터 메시지를 받는다.
각각의 메일박스는 유니크한 id를 가지고 
당연히 프로세스가 메일박스에 접근을 할 수 있어야 데이터 교환이 가능하다.
메일박스 기반의 통신은 단방향 양방향 다될수있다.

47p
일단 메일박스(port)를 만들고
메일박스를 통한 송수신
메일박스 파괴 순으로 이루어진다.
A(메일박스)에게 메시지를 쓴다. 그리고 A로부터 메시지를 받는다 => 간접적으로 이루어지는것.

48p
P1이 메시지를 보내고 P2 P3가 메시지를 받는다.
이렇게 일대다 통신이 가능한데, 메일박스 입장에서는 P2가 먼저 메시지를 받아가고
P3가 그다음 메시지를 받아가는 순차적인 형태로 이루어진다.
누가 먼저 접근을 하느냐는 os의 전략에 따라 달라진다.

49p
동기화의 관점에서 보면 어떻게되는가?
Blocking = 동기화, non Blocking = 비동기화
Blocking send = 어떤 송신측이 자기가 보낸 메시지가 수신측에 의해서 읽힐수 있을 때
까지 블락 되고 그다음에야 두번째 메시지를 보낼 수 있다. => 수신되기 전까지 새로운 
메시지를 보내지 않는다.
Blocking receive = 메시지가 올때까지 블락 => 당연히 블락된다 쉬운개념이다.
Non-blocking send = 센더가 메시지를 보내고 자기 할일 하는거, 계속 보낼 수 있다.
보낸 메시지는 큐에 저장되고 그 큐는 무한의 크기를 가져야 한다.
Non-blocking receive = 리시버가 블락되지 않는다. => 수신측에서 계속 읽지만 메시지가
 있으면 계속 읽는거고 없으면 없는구나로 끝낸다.
Blocking은 버퍼같은 버퍼가 필요없다 이런것을 랑데뷰라고 한다. => 송 수신측이
정확히 동기화 되는것.

50p
blocking과 non blocking의 diagram 설명.

51p
랑데뷰는 blocking 전략을 사용할때를 말한다. 비효율적인 방식이다.

52p
버퍼링 관점에서 지금까지 내용을 살펴보자
버퍼링이랑 송 수신자 사이에 중간에 필요한 que를 버퍼라고 한다.
1. 이 que가 필요가 없을때 => 랑데뷰상황
2. que가 한정적일 경우 => 복잡한 송 수신상의 메커니즘이 필요하다
3. que가 무한일 경우

53p
POSIX 표준 관점에서 shared memory 방식을 살펴보자.
1. 첫번째는 shared 메모리를 만들어야한다.
2. 그럼다음에 그 메모리의 크기를 fix한다.
3. 그리고 이 공유된 메모리에 writing을 하면 메시지가 저장된다. 수신측에서 읽으면 된다.

56p
Mach를 예를 들어 보자.
send, receive는 직접적으로 메시지 패싱을 기본으로 한다. rpc는 주소공간이 서로다른
network 상에서 많이 쓴다. Mach는 기본적으로 메시지 통신 기본이다.
심지어 시스템 콜 자체도 메시지 통신을 기본으로 이루어진다.
shared memory = 프로세스 자기자신 주소공간 내의 메모리를 공유하는 것.
mailbox(port) = 시스템 상에서 제공하는 제3의 통신 매개체

57p
윈도우즈에는 advanced local procedure call(LPC)을 만들고 있다.
메일박스처럼 포트기반으로 통신채널이 만들어진다. 그런데 약간 다른 포트이다
connection port, communication port 두개가 있다.
communication port는 우리가 아는 데이터가 오가는 포트이고, 추가로 connection port는
서버가 connection port를 만들고 시스템에 알려준다. 그러면 클라이언트가 특정 프로세스와
통신을 하고싶을 때 이 컨넥션 포트를 하나 더 오픈한다. 그런다음 이 클라이언트는
이 connection을 가짐으로써 통신을 요청하면 서버는 communication port를 만들어준다.

58p
클라이언트가 컨넥션 포트로 컨넥션 요청을 보내면 서버는 클라이언트용 통신 포트.
서버용 통신 포트를 만든다. 이 두가지를 이용해서 클라이언트와 서버가 통신을 한다.
그런데 추가로 하나가 더있다. 작은 메시지는 위에 설명한 것처럼 포트를 통해서 이루어지지만
큰 메시지는 shared section memory = shared memory 를 기반으로 한다.

59p
Local, Remode 프로시져 콜의 차이.
Local 프로시저 콜 = 두 클라이언트와 서버가 동일한 주소공간을 가지는 경우.
Remote 프로시저 콜 = 네트워크를 연결해서 가기 때문에 서로 다른 주소공간을 가짐.
=> 메시지 패싱을 기반으로 하면서 자기가 원하는 프로세스의 주소공간과 매핑이 되는
메커니즘 필요

61p
소켓
소켓은 IP주소 + port, 두개의 네트워크 상에서 두 프로세스가 running할때
(같은 컴퓨터 아닐수도 있다) two-way 커뮤니케이션을 위한 추상적인 endpoint이다.
멀리 떨어져있으니가 IP주소 있어야하고 각각의 매개체(port)가 있어야한다.

62p
소켓이라는 것은 송수신 데이터를 위해서 추상적인 통신 개념이다. 파일 입출력을 할때와
비슷하게 app에서의 두 프로그램의 통신을 위한 추상적인 개념이다.
underlying 프로토콜(TCP or UDP)에 따라서 서로 다른 소켓 개념이 존재한다.

63p
ip주소 + 포트 개념으로 통신을 한다.

65p
RPC(Remote Procedure Call)은  서로 떨어져있는 컴퓨터 사이에 두 프로그램이 동작이 될 때,
이 둘사이의 프로시저 콜(함수 콜하는 것 처럼 프로세스를 콜하는것) 위해서 
프로시저 콜(메시지 전송 아님 call 이다) 자체를 추상화 시켰다,
원격지에 있는 Server의 함수를 Call 한다고 생각하면 됨.
클라이언트 코드에서 먼저 Client Stub이라는 것을 콜하고, 서버쪽에서 어떤 함수를 콜을 할지,
파라미터를 만들어서 네트워크 통신을 통해서 server stub이라는 쪽에 보내면 이것을 분석해서
해당되는 서버의 코드를 call 하는 절차를 가진다. 그리고 그 코드를 계산해서 그 결과를 리턴하면
다시 Sever stub을 거쳐 네트워크를 통해 Client stub에 가고 거기서 다시 분석해서 해당되는
클라이언트 코드에 리턴한다.
클라이언트 코드 입장에서는 그냥 자기 자신은 call을하고 결과를 리턴하는 것 같다. 마치
로컬 프로시져 콜처럼. 이것을 지원하는 것이 RPC이다.
클라이언트 stub은 서버가 어디있는지 찾고, 파라미터들을 만들어서 보낸다(marshaling)
서버 stub쪽에는 marshaling된 파라미터를 받아서 이것을 unpacking 하고 자기 자신의
해당 프로세스를 call 하고 결과를 넘겨주는 역할을 한다.

67p
빅 엔디안, 리틀 엔디안으로 될 수 있고.
네트워크를 통해서 가니까 당연히 중간에 전송이 안될 수 있고, fail이 날수도 잇다.
따라서 메시지를 딱 한번 보내거냐 그냥 쓸데없이 계속보내거냐 하는 정책이 있는데
대부분 복잡성을 없애기 위하여 딱 한번 보낸다.
결국은 RPC는 오류가 많이 난다. 하지만 정확히 실행이 되어야 한다.
따라서 한번 보내고 실패하면 확인하고 다시 보내고 이런식으로 통신을 한다면 
exactly once 통신이 가능한 것이다.

69p
Pipe
parent 와 child관계에서만 실행이 되는것이 일반적임.

70p
producer는 쓰고 consumer는 읽는 형태가 되고 이것이 unidirectional 이고 당연히 bidirection
형태로 만들 수 있다.

71p
네임드 파이프는 바이 다이렉션 되고 parent child 관계가 아니라 일반적인 프로세스에서 통신이 된다.
