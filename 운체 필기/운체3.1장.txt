3p
프로세서란 실행중인 프로그램.
프로세서가 실행될 때 스케쥴링, 생성, 종료, 통신 문제가 발생한다.
공유된 메모리나 메세지를 보내는 것으로 프로세서간 통신이 이루어 질 수 있다.

4p
단 하나의 작업만 실행할 수 있는 시스템 => 배치 시스템에서 작업은 jobs
시분할 시스템 에서는 작업을 tasks라고 한다.
프로그램 카운터라는 개념 존재.
프로세서는 여러 파트로 구성이 된다.
프로그램 코드가 들어 있는 부분을 text section
스택 영역이 존재한다. 파라미터, 리턴주소, 로컬변수 들이 스택에 들어간다.
전역변수는 data section에 들어간다.
heap이라는 영역에 동적으로 할당된 공간이 저장된다.

5p
프로세스는 실제 실행 코드, data영역, stack 영역, 프로세서를 제어하기 위해 필요한 영역(프로그램 카운터값, 레지스터값..) = process context
program context는 스택 포인터, 프로그램 카운터와 관련된 부분 같은것들로 구성되어 있다.

6p
프로세서는 실행가능한 프로그램이 메모리에 로딘된다.
각 영역의 그림은 다음과 같다.

7p
프로세서가 생성이 되는 new state,
프로세서가 준비 완료 된 ready state,
인터럽트가 걸리면 running state 에서 ready state로 다서 간다.
입출력 이벤트가 생기면 waiting state로 빠져 있다가, 입출력 이벤트가 끝나면 다시 ready state로 간다음 기다린다.
실행 종료되면 terminated state로 바뀌고 삭제됨.

8p
프로세스 컨트롤 블럭(PCB) = task control block
여기에는 프로세스가 현재 어떤 상태인지의 정보를 가지고 있다.
또 프로그램 카운터 값,  cpu register은 프로세스와 관련된 레지스터 정보들,
스케줄링과 관련된 정보들 등을 가지고 있다.

9p
전체적으로 보면 두개의 프로세스가 등장한다.
프로세스 P0가 쭉 실행된다. 그러다가 P1에 의해 인터럽트 걸린다.
이때 P0와 관련된 state정보를 PCB0라는 블럭에 저장하고, cpu로 PCB1이라는 블럭이 로딩되어 실행된다. 다시 P1이 P0에 의해 인터럽트 걸리면 다시 PCB1으로 저장하고 PCB0를 복원하여 P0를 실행시킨다.

10p
쓰레드는 쉽게 말해 프로세스는 실행되는 흐름이 하나이고, 쓰레드는 여러개다 라고 보면된다.
쓰레드는 프로그램 카운터가 여러개이다. 여러개를 실행 할 수 있다.

11p
리눅스로 후에 실습한다. 뒤의 스케줄링은 나중에 배운다.