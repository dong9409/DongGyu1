3p
cpu 스케쥴링에 대해서 살펴본다.
cpu 스케쥴링은 멀티 프로그래밍 운영체제의 가장 기본이다.
코어가 여러개 일때 그 코어가 효율적으로 여러 프로세스가 사용할 수 있도록 하고
비록 코어가 하나라도 cpu 스케쥴링에 의해서 여러개의 프로세스가 동시에
실행되는것처럼 보이게 만드는것이 cpu 스케쥴링이다.

4p
프로세서가 하나인 단일 처리기 시스템에서는 오직 한순간에 하나의 프로세스만이
사용될 수 있다. 나머지 프로세스들은 cpu가 자유 상태가 될 때까지 기다려야한다.
다중 프로그램의 목적 자체는 cpu 이용율을 극대와 하는 것.
cpu 이용률을 극대화 한다는 것은 어느 순간의 코어에는 항상 어떤 프로세스가
실행이 된다는 뜻이다.
이 어떤 프로세스는 cpu 연산과 입출력 연산으로 구성이 될것이다.
cpu연산이 많은 경우 cpu burst라고 하고 시간이 많이 걸리는 입출력 장치에 관련된
명령어를 I/O burst라고 한다. 따라서 어떤 프로세스의 실행 자체는 cpu burst와
I/O burst 사이클로 구성이 된다고 할 수 있다.
cpu의 이용률을 높이기 위해서는 cpu를 사용하는 명령어(cpu burst)를
많이 실행할 수 있게 만드는 것이다.

5p
cpu burst의 지속시간은 생각보다 짧다. cpu burst가 긴 경우는 많지 않다.
이 분포가 왜 중요하냐면 어떤 프로세스가 cpu를 사용할수 있게끔 할당 되는것을 
cpu 스케쥴링이라고 하는데 이 cpu 스케쥴링 알고리즘을 만들 때
cpu burst 시간이 비교적 짧다는 경우가 많다 라는 특성을 활용하여
짜면 되기 때문이다.

6p
지난 시간에 short  term, medium term, long term scheduler를 배웠다.
shrort term이 레디큐에 있는 프로세스 중에서 cpu에 할당했는데 이게 바로 
cpu 스케쥴러다.
cpu 스케쥴링은 프로세스가 어떤 상황일때 결정이 일어나는지 살펴보자.
1. 어떤 프로세스가 실행이 되고 있는 상태에서 waiting 상태로 전환되었을때 cpu가
비니까 새로운 프로세스가 cpu에 할당되어야한다.
2. 지금 실행되고 있던 프로세스가 레디큐로 가는 경우. 구체적으로 인터럽트가 발생된
경우, 지금 실행중인 프로세스가 ready state로 바뀐 경우
3. ready state에서 다시 cpu 실행을 위해서 스케쥴링이 되어야 하는 경우
4. 현재 실행되는것이 다 끝나서 cpu가 비어있을때
1번 4번은 새로운 프로세스가 반드시 실행이 되어야 한다. cpu가 비어있으니까
그런데 2번과 3번은 기존에 실행이 되다가 인터럽트에 의해서 waiting state에 있다가
다시 오는 거니까 누구를 실행 시킬거냐가 issue가 된다.

7p
선점형 스케쥴링에는 공유해야할 점이 있다.
1. 데이터를 공유할 경우
여러 프로세스가 데이터를 읽거나 쓸 수 있을 경우, 어떤 프로세스가 먼저 접근을
하느냐에 따라서 내용 자체를 바꿀 수 있으므로 경쟁 조건이 발생 할 수 있다.
2. 커널 모드에서 동작할 경우
어떤 프로세스가 system call을 하면 커널모드에서 동작이 이루어진다. 이경우
선점이 발생하면 커널상에서의 자료들이 변경이 될 수 있다. 그래서 어떤 프로세스가
커널모드로 동작이 될때 새 프로세스가 선점에 의하여 실행되면 데이터에 대한 동기화
뿐만 아니라 자료의 변화들을 잘 고려해야한다..
3. 인터럽트를 어떻게 처리할 것이냐
중요한 os 동작을 실행할때 인터럽트가 발생한다. 인터럽트를 처리할때 또다른
인터럽트가 발생하면 일관성 문제가 생긴다. 대부분의 프로세서 에서는
인터럽트를 실행할때 다른 프로세스에 의한 인터럽트는 받지 못하게끔 disable 시킴
그리고 인터럽트 다끝나면 다시 인터럽트를 enable시킴.

8p
디스패처란 short term 스케쥴러가 선택한 프로세스에 cpu제어권을 준다는 개념이다.
어떤 프로세스가 cpu 제어권을 얻는다는 말은 실행이 된다는 말.
그래서 디스패쳐는 switching context, switching to user mode, 사용자 프로그램의
적절한 실행 위치로 점프하는 기능을 가진다.
다시 정리하면 디스패쳐 라는 것은 short term 스케쥴러가 프로세스에게 cpu 사용권을
준것이다. 그러면 당연히 그 프로세스에 관련된 내용이 실행이 되어야 한다.
그러면 컨텍스트 스위칭이 일어나고 즉 유저모드로 변환되고, 적절한 실행포인트
(프로그램 카운트)의 값을 찾아서 점프 해줘야한다.
Dispatch latency 디스패처가 기존 프로세스를 stop 시키고 새로운 프로세스를 시작하기
전까지 걸리는 시간이다.

9p
cpu scheduler가 고려해야할 점
cpu 이용률을 높이자,
Throughput을 높이자 => 단위시간당 처리되는 일을 높이자.
Turnaround time(총 처리시간) 어떤 프로세스의 처음부터 끝까지 걸리는 시간
어떤 프로세스가 complete a request 할때까지 걸리는 시간. 시작시간 과 끝시간의 차이
Response time(응답시간)은 어떤 프로세스가 실행이 될때 첫번째 응답이 올때까지의
시간이다. 총 처리시간이 응답시간보다 당연히 길게된다.
이메일을 보냈는데 응답을 얼마나 빨리하는가와 같은 시간. 요청이 갔는데 첫번째
응답이 올때까지 걸리는 시간. 일을 다끝낼때의 시간이 아니다.
Waiting time(대기시간)은 레디큐에서 기다리는 시간이다.

10p
그러면 이 스케쥴링을 최적화시키기 위한 기준 조건은 뭘까
cpu 이용률 최대화
throughput 최대화
turnaround time 최소화
waiting time 최소화
response time 최소화

11p
FCFS 스케쥴링 알고리즘에 대하여 알아보자.
프로세스 P1 P2 P3가 순서대로 왔고 버스트타임은 24 3 3이라고 하자.
그러면 P1은 제일 빨리왔으니까 제일 빨리 실행된다. 평균대기시간은 17이 걸린다.
FCFS는 효율적인 기법이 될 수 없다.

12p
조금 바꿔서 먼저 도착했지만 짧은것을 더 먼저 실행 시켜주면
평균대기시간은 17 -> 3으로 뚝 떨어진다. 이런 FCFS효과를 Convoy(호위) 효과라고
한다. 하나의 긴 프로세스가 있다고 하면 모든 프로세스는 그게 끝날 때 까지 
쭉 기다린다. 그림을 보면 아주 긴 프로세스가 처음에 온다. 그러면 훨씬더 짧은
프로세스들은 기다릴수 밖에 없다. 이 convoy 효과에 의해서 starvation 현상이 생긴다.

13p
Shortest Job First 스케쥴링 (SJF)에 대해서 알아보자.
CPU 사용 시간이 가장 짧은 프로세스를 먼저 실행시키는 방법이다.
여기서 중요한 것은 Process 전체 길이가 아니라 CPU burst 길이를 고려한다는 점이다.
SJF는 사실 최적 솔루션이다. 하지만 어떤 프로세스의 길이는 알수 있지만,
CPU burst의 길이는 사실상 알 수가 없다. 프로그램을 다 실행시켜봐야 알수있다.
그래서 cpu burst시간을 정확히 알 수 없는 어려움이 있어서 예측할 수 밖에 없다.

14p
SJF 예를 보자. burst time을 짧은 순으로 실행시키면 된다.

15p
cpu burst를 정확히 몰라서 예측한다고 했는데 그 알고리즘을 알아보자.
이전의 상황의 정보를 가지고 예측한다.
exponential averaging(smoothing) 기법
1. tn = 실제 n번째 cpu burst의 실제 시간
2. Tn+1 = n+1번째의 cpu burst의 예측 시간
3. Tn+1 = atn + (1-a)Tn
보통 a는 0.5로 둔다.
표를 보도록 하자. a = 0.3으로 둔다
Demand(실제정보) Forecast(예측 정보)를 가지고 다음을 예측하겠다라는 의미
계산해서 나온게 다음예측이다. 계속 이렇게 예측을 진행한다. 이 예측 정보를 가지갸ㅗ
스케쥴링을 한다.

16p
실제시간 예측시간의 표

17p
a = 0이면 무조건 현재의 정보는 고려하지 않고 무조건 예측값만을 가지고 본다
a = 1이면 현재 값만 가지고 예측한다.