18p
현대의 os에서 동시에 여러 프로세스가 실행 되어야 한다.
이런 멀티태스킹을 지원해 주는 것이 전에 보았던 스케쥴러 이다.
모바일 OS상에서도 멀티태스킹을 지원하지만, 사용자는 화면 중심으로 스마트폰을 사용하기
때문에, 화면 권한을 가지는 프로세스에 비중을 더 많이 두고 있다.
예를 들어 안드로이드는 4개의 메인 컴포넌트를 가진다.
이중 서비스는 UI가 없고 백그라운드에서 돌아가고 있다. 사용자에 보여지지않고 태스크를
처리한다. 결국 모바일 에서 멀티태스킹은 리눅스 같은 것과 특성이 다르다. 백그라운드에서
실행되는 프로세스들의 스케쥴링 방식, 생명주기가 리눅스 같은 것과 다르다는말.

19p
멀티태스킹에는 반드시 context switch 개념이 나와야함.
씨피유가 다른 프로세스를 실행하기 위해서는 당연히 그쪽과 관련된 레지스터, 스택 등을
확인해야한다. 씨피유가 다른 프로세스를 실행하러 갈때 지금 실행하고 있는것들을 다 저장
해야한다. 이게 앞에서 배운 PCB에 들어간다. 이렇게 바꾸는게  context switching 이라고 한다. 
이렇게 전환할때 걸리는 시간이 간접비용이다.

20p
프로세스가 생성되고 종료되는등 프로세스와 관련된 함수들에 대해 살펴보자

21p
parent프로세스가 child프로세스를 생성하는 것을 보자.
기본적으로 프로세스는 pid를 가진다. parent와 child는 리소스를 공유하거나 공유하지않거나
하는 방식이 있고. parent와 child가 동시에 실행 되거나 parent가 기다리거나 하는 경우도 있다.

22p
parent child 관계의 다이어그램이다.
PPID는 parent process ID이다. pid와 ppid로 parent child 관계를 알 수 있다.

23p
리눅스 상에서 프로세스가 생성 되는것은 fork를 쓴다.
fork를 하면 child process pid=0이다. exec는 fork이후에 실행된다.
즉 fork 이후에 exec하면 특정 새로운 프로그램이 실행이 된다.

24p
fork이 될 때를 자세히 살펴보자.
cpid = child process의 id이다.
cpid=0이면 child process라고 보면 된다.
fork는 프로세스 복제하고, parent이면 child의 pid, 즉 cpid를 리턴하고, child이면 0을 리턴한다.
cpid값으로 child, parent 코드를 선택하여 실행시킨다.
종료되면 parent로 cpid가 전달되어 wait(cpid)이후 코드가 실행된다.

26p
exec()는 현재 프로세스 내용을 새로운 프로세스의 내용으로 대체하는 것이다.
이전에 child코드를 실행 하라고 했는데 이게 exec("foo") 라고 하면 foo함수를 실행하라고 하는 것이다.
그러면 foo함수와 관련 정보가 cpu에 loading 되고 foo가 실행된다.

30p
exit()을 하면 프로세스가 정상적으로 종료된다.
그러면 parent 프로세스가 wait()라는 함수로 child의 pid를 받아서 정상적으로 
process resource가 os로 하여금 할당이 해제된다.
그런데 Abort() 함수는 Parent가 child를 강제로 종료시키는 것인데,
child 프로세스가 허락된 리소스 한계를 넘어서거나,
더이상 child 프로세스가 필요하지 않을때,
아니면 parent가 죽어버릴때, Abort가 실행이 될 수 있다.

31p
cascading termination = 단계적으로 child, grandchildren.. 과 같이 연결되어 종료되는 것.
child프로세스가 종료되면 parent에서 cpid를 받는다.
좀비 프로세스와 orphan프로세스가 있다.
좀비 프로세스 = child가 정상 종료 되었을 때 wait() 하고 있는 parent 프로세스가 없을 때.
후속 작업이 이루어 지지 않아서 process table이 남아 있는 것.
=> 부모가 wait를 호출하기 전에 자식프로세스가 종료되는 경우
orphan 프로세스 = parent가 wait 없이 죽어버리면, child가 정상 종료 되어 끝났는데 
orphan 상태가 된다.
=> 부모가 먼저 종료된 자식 프로세스의 경우
이 둘이 뭐가 다르냐면, orphan의 경우 init 프로세스가 parent를 대신해서 wait를 호출해준다.

33p
중요한 프로세스간의 커뮤니케이션을 보자
프로세스간 협력을 하려면 통신이 필요한데 이것을 interprocess communication 라고한다.
방법은 두가지가 있는데
shared memory, 메세지 전달방식 이 있다.

34p
(a)메세지 큐에 프로세스 A가 던지면 프로세스 B가 받아서 쓴다.
(b)프로세스 A, B는 메모리를 공유한다.

35p
communication 하는 이유.

36p
프로세스가 협력하는 것을 모델링하면 누구는 데이터를 보내고 누구는 받아야 한다
이것을 producer consumer 문제 라고한다.
서로 공유하는 메시지의 사이즈가 한정되어 있으면 bounded
무한정이면 unbounded buffer 모델이라고 한다.

37p
예를 들어보자
프로듀서가 먼저 작업을 끝내서 컨슈머에게 보내려고 했는데 컨슈머가 받을수 없는
상황이었다. 그래서 (a) 까지 쭉 기다리고 있다고 하자. (1)상태가 기다리는 상태이다.
(2)은 컨슈머가 받을수 있는 상황이니까 데이터를 보내서 받았다. 그러면 프로듀서는
2단위 작업을 할수있다. 그런데 컨슈머는 1단위 작업 끝내고 놀고있다. 또 컨슈머가
2단위 작업을 하고 있을때 프로듀서는 작업을 끝내도 못보낸다. 이렇게 대기하는
시간을 최소하 시키는게 프로듀서 컨슈머 모델의 최적이다.

38p
그래서 일반적으로 중간에 버퍼를 도입해서, idle상태에 있는것을 최소화 시키는것이다.
그런데 기본적으로 프로듀서와 컨슈머는 독립적으로 동작하기 때문에 정상 동작이 안될
확률이 굉장히 높다.

39p
P와 C가 직접적인 통신이 없는 상황인데, 통신을 하여 각각의 buffer 상태를 알 수 있으면
정상 동작이 가능하다.

40p
한 사례를 보자.
in = 다음 빈 위치
out = 첫번째로 채워져 있는 위치
나머지는 코드를 보고 이해하자. 버퍼7에 값을 못쓰는 코드이다.