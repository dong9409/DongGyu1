4p
기본적인 현대 어플리케이션은 쓰레드를 여러개 지원한다.
예를들어 브라우저를 보자
브라우저는 이미지를 디스플레이하고 업데이트하는기능
서버로부터 데이터를 가져오는 기능
오타를 체크해주는 기능
네트워크 요청 기능
이러한 기능들이 프로세스들이 하나의 프로세스에 의해서 실행된다고 하자
만약 네트워크요청 기능이 매우 느린 작업이라고 하면 이 작업때문에 브라우저는
멈춰버린다. 하지만 멀티 스레드로 구현하면 이런것들을 해결 할 수 있다.
또 쓰레드를 사용하는 다른 이유는 쓰레드를 하나만 가지는 프로그램은 heavy weight
하지만 쓰레드 하나를 새로 생성하는것은 light weight 하다.
그리고 요즘 os의 대부분의 커널은 기본적으로 멀티스레드를 제공하기 때문에 
멀티스레드를 기본으로 프로그램을 구현하는게 좋다.

5p
서버가 멀티스레드 기능을 갖추고 있다고 가정하자.
client A가 서버에 요청을 하게 되면 서버는 그냥 요청을 처리하는 스레드를 만들어서 
스레드에게 그 일을 넘겨버린다. 그러면 clientB 가 요청을 하더라도 또다른 스레드를
만들면 되니까 새로운 request를 계속 받을 수 있다.

6p
스레드의 장점
1. 요청에 대한 응답성이 좋다 
2. 자원 공유가 쉽다. => 프로세스 간에 통신을 위해 메시지박스를 쓰거나 shared memory
를 쓸수밖에없다. 하지만 스레드는 같은 데이터나 코드 영역을 sharing 할 수 있다. 그래서
효율적이다
3. 생성할때 더 low cost이다. 그리고 switching이 프로세스간 스위칭인 context switching
보다 훨씬 low cost이다.
4. 전통적인 프로세스는 멀티코어라도 결국 어느 한순간에 코어 하나에서 밖에 실행 될
수 밖에 없지만 멀티 스레드는 각각의 코어에 실행이 나누어 져서 실행 된다. 그래서
확장성(Scalability)이 좋다

7p
병렬성과 병행성의 차이에 대해서 살펴보자
parallelism = 어느순간에 보면 동시에 하나의 task 이상이 실행이 되고 있다라는 뜻
concurrency = user 관점에서 보면 여러개의 task가 실행이 되고있는것 처럼 보인다.
멀티 코어나 멀티 프로세서 프로그래밍에서 고려해야될 점
1. Dividing activities = task 쪼개는 문제, 병렬 실행 가능하냐?
2. Balance = 두개의 태스크가 있다고 하자 하나는 엄청 빠르고 하나는 엄청 느리다.
오래걸리는 프로세스를 더 쪼개서 두개의 프로세서에 적당히 분배하면 둘다 결과를
빨리낼 수 있는데 이러지 못하면 균형이 안맞다. 즉 태스크를 쪼개서 지연시간 이나
계산시간을 고려해서 밸런스를 맞추는것에 대한 문제이다.
3. Data splitting 당연히 태스크를 쪼개니까 데이터를 어떻게 쪼개느냐도 중요한 issue다
4. Data dependency가 강한 경우 태스크를 쪼갤 수 어렵다.
5. Testing and debugging 멀티 프로세서 통신이 일어나면 테스트와 디버깅이 더 복잡해
진다.

8p
병렬성은 또 데이터에 대한 병렬성과 task에 대한 병렬성으로 나누어진다.
밑에 보이는게 프로세서 하나이다. 8개의 코어를 가지는 프로세서이다.
위에 나온 점들을 고려하여 설계를 잘 하면 태스크 4개를 동시에 실행 할 수 있다.

9p
concurrent는 시분할로 거의 동시에 실행되는 것 처럼 보인다는 뜻이다.
다시말해 하나의 코어에서 시분할을 통해서 concurrent하게 실행 되고 있다라고 말한다.
parallelism은 실제로 T1 과 T2가 동시에 실행되고 있다. 멀티코어 시스템에서 쓰인다.

10p
스레드와 프로세스는 당연히 다르다. 그렇지만 스레드라는 것을 보면 어떤 프로그램의 
흐름 자체, 하나의 flow of process 이다. 우리가 생각하는 프로세스는 정확하게 
표현하면 single threaded process 이다. 대신 멀티 쓰레드 프로세스는
위쪽에 코드, 데이터, 파일을 공유하는 곳이 있고 각각의 쓰레드 마다 레지스터와 스택이
따로 있다.

11p
암달의 법칙
S를 어떤 프로그램중에 동시에 실행될 수 없는 부분이라고 한다.
N을 코어의 개수라고한다
N이 무한대로 가면 결국은 1/S로 인해 스피드가 결정이 된다.

12p
스레드의 구조를 크게 사용자 스레드냐 커널 스레드나 이렇게 보고 있다.
당연히 사용자 스레드는 유저 애플리케이션에 의해서 관리가 된다.
커널 스레드는 실제 커널에서 몇개의 스레드를 지원하는지가 이슈가 된다.

13p
사용자 스레드와 커널 스레드는 연관 관계가 있다.

14p
n대1 모델
사용자 스레드는 여러개이고 커널 스레드는 하나이다.
사용자 스레드는 총 4개인데 맨 왼쪽 것을 쓰레드 1이라고 하자
이게 실제 실행이 되는것은 커널 쓰레드에 assign이 되어서 실행이 된다.
그러면 나머지 3개의 스레드는 blocking 될 수 밖에 없다.
이러한 모델에서는 하나의 스레드가 blocking이 되면 나머지 스레드도 blocking이 될 수
밖에 없다. 요즘은 이런모델을 안쓴다.

15p
1:1 모델
유저스레드와 커널스레드가 1:1 이다
만약에 유저스레드를 많이 생성 하면 성능이 떨어질 수 밖에 없다. windows, linux..

16p
m:m 모델
얼핏 보면 좋은것처럼 보이지만 옛날 모델이다

17p
Two-level model
유저스레드 하나는 특정한 커널 스레드에 맵핑 시키고 나머지 유저 스레드는 나머지 커널
스레드들에 적절히 맵핑시켜서 사용한다.