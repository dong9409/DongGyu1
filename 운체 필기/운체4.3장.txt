27p
암묵적 쓰레딩 기법에 대해 살펴보자.
프로그래머가 직접 멀티 쓰레드 프로그램을 개발하는경우 explicit 쓰레드
반면 컴파일러가 알아서 멀티쓰레드 프로그래밍을 하는 경우 Implicit 쓰레드
프로그래머가 직접 하는것은 쉽지 않은 일이라 암묵적 쓰레딩을 많이 쓴다.
암묵적 쓰레딩의 대표적 3가지 방법이 있다.
1. Tread Pool
2. OpenMP
3. Grand Central Dipsatch

28p
쓰레드 풀은 이름에서 알 수 있듯이 쓰레드가 있는 집단이 있다는 뜻.
프로세스가 시작하는 시점(start up)에 여러개의 쓰레드를 미리 만들어 두고(pool에)
여기에 있는 쓰레드를 활용한다.
기존에 있는 쓰레드를 활용하는 것이기 때문에 빠르다.
어떤 시점에 사용할 수 있는 쓰레드의 갯수를 제한할수 있는 효과가 있다.
쓰레드를 생성하는것과 실행하는 메커니즘을 분리하게되면 여러가지 스케쥴링 전략을 만들고
실행시킬 수 있다. Thread pool에 있는 쓰레드 갯수는 코어 갯수라던지 메모리 용량이라던지를
고려해서 정할 수 있다.

29p 
쓰레드 풀을 사용했을떄의 특성들이다.
쓰레드가 필요한 상황이 생기면 쓰레드 오브젝트가 생기고 메모리를 할당한다.
하지만 쓰레드 풀은 풀에 있는 쓰레드를 선택해 사용하면 되므로 훨씬 빠르고 효율적으로
사용이 가능하다.

30p
OpenMp방식
컴파일러가 알아서 task를 분할한다.
OpenMp는 shared memory 방식이다.
for 루프가 멀티쓰레드의 대상이되는 코드 영역이다.
몇개로 나누어 지냐는 프로세서의 코어 특성에 의해 결정된다.
pragma omp parallel => 병렬처리가 되는 코드영역.

31p
OpenMP
코어가 많아짐에 따라서 컴파일러가 알아서 멀티쓰레딩 해주는 목적.
프로세스들이 메모리를 공유한다.

32p
대형 서버급 컴퓨터에서 OpenMP방식을 지원한다.
fork하면 그 결과를 다 모아서 join하고 다음 단계로 간다.

33p
Grand Central Dispatch 맥 os에서 많이 쓰는 방식.
병렬 처리가 가능한 방법을 정하는데 그 방법은 ^{} 형태로 블락 형태로 표시힌다.
쓰레드 풀에 가용 쓰레드가 있다면 중괄호안의 문장이 실행이 된다.
어떤 쓰레드에 이 코드를 해야할지 이런걸 전혀 생각하지 않고, 대상이 되는 코드를
블럭형태로 표현하면 GCD 디스패쳐에 의해 적절히 큐에 할당이 되고, 쓰레드풀에서
가용 쓰레드가 있으면 실행이 되는 형태이다.

35p
GCD에서 결국 개발자는 어떤스레드에 뭘 할당할지 이런걸 신경 쓸 필요 없고
위에 나온 방법으로 표현만 해주면 GCD디스패치는 알아서 쓰레드에 할당 해준다.
쓰레드 풀을 사용하기 때문에 너무나 많은 쓰레드가 생성되는것도 제한한다.
개발자는 저수준의 작업을 고민할 필요 없다.

36p
여기에 보면 여러가지 Queue가 있다. GCD 큐를 보면 여러가지 우선순위를 가지는 que가 있다.
GCD 쓰레드 풀에 가용 쓰레드가 있다면 해당되는 쓰레드를 실행한다.

37p
멀티 쓰레드와 관련해서 fork, exec, cancel에 대해 살펴본다.

38p
exec는 프로세스든 쓰레드든 100퍼센트 동일하다고 보면 되는데 fork은 다르다.
프로세스에서 fork을 하면 child 프로세스가 만들어 진다. 
그런데 하나의 프로그램 내의 하나의 쓰레드가 fork했다고 가정하자. 프로세스에 보면 fork을한
쓰레드 하나가 있고 그 외의 또다른 쓰레드가 있다. 그러면 fork을 통해서 쓰레드 하나만 
복제되느냐, 아니면 여러 쓰레드가 포함이 되는 프로세스 전체가 fork이 되느냐 하는 질문이
있을 수 있다. 쓰레드가 fork을 실행 했을때,새로운 프로세스는 쓰레드를 전부다 복제할 것인가?
아니면 해당되는 그 쓰레드만 복제 할 것인가 하는 문제이다. 두가지 다 경우가 있다.
유닉스에서 어떤 전략을 취하느냐에따라 달려있다고 보면된다, 이 두가지 기능을 다 가지고 있다.
예를 들어 fork을 한 다음에 바로 exec가 실행이 된다고 하면, 하나의 쓰레드만 복제되어서 실행
되는 경우가 있고, fork만 했다면 프로세스에 있는 모든 쓰레드가 다복제가 되어 있는 경우가
일반적이다.

39p
signal 이라고 하면 프로세스간 이벤트를 보내기 위해서 사용한다.
수신측에서는 signal을 처리하는 signal 핸들러가 있다,
동기식, 비동기식으로 보내는 방법이 있다.
signal 핸들러는 커널에서 기본적으로 제공하는 default 핸들러가 있고
user defined된 signal 핸들러를 구현 할 수 있다.
user defined된 signal 핸들러는 default 핸들러를 override 해서 구현할 수 있다.

40p
전송하고자하는 signal이 멀티쓰레드 환경에서는 어떤 쓰레드에 전송이 되어야 할까?
특정 쓰레드에 전달이 되거나, 프로세스에 있는 모든 쓰레드에 전달 될 수 있다.
전달하고자하는 signal이 어떤거냐에 따라서 정해진다. 예를들어 컨트롤+c로 프로세스를
강제종료하는 signal 같은 경우는 그 프로세스 내에 있는 모든 쓰레드에 전송이 되어야한다.

41p
쓰레드 취소
쓰레드를 취소하는 거니까 당연히 특정 쓰레드에 이 signal이 전송이 되어야한다.
쓰레드 취소를 보면 비동기식, Deferred(지연된)식이 있다.
비동기식은 기다림 없이 타겟 쓰레드를 취소시킨다.
Deferred 취소는 주기적으로 체크를 당할 때 까지 취소가 지연이 된다. 타겟 쓰레드가
주기적으로 취소 신호를 체크해서 취소하는 형태이다.
쓰레드 취소에서 또 다른 문제를 보면 어떻게 자원을 회수 할 것이냐 이다. 비동기식은
시스템 자원을 반환 하지 않고 취소되는 경우도 종종 발생한다.

42p
실제 취소작업은 이전에 봤던 취소요청을 어떻게 처리하느냐에 따라 달라진다.
모드가 off이면 취소신호가 와도 취소를 안한다는 뜻이다.
Deferred, 비동기식 취소 모드가 있다.
Deferred는 어느시점에 체크를해서 그 시점에 캔슬이 일어난다,
그러면 그 시점을 어떻게 설정 할 것인가
pthread_testcancel()을 설정해서 그 시점을 설정 할 수 있다.
그 시점에서 cleanup handler가 캔슬 해준다.