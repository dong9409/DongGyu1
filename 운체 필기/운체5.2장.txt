18p
Shortest remaning time first = 선점형 SJF 알고리즘
남아 있는 잔여시간을 가장 먼저 고려하는 알고리즘이다.
P1이 맨처음 들어왔으니까 당연히 P1이 먼저 실행이 된다.
P1의 burst time은 8이다. time이 1일때 P2가 들어온다 P2의 burst time이 4다
그래서 P2가 먼저 실행된다. 이 때보면 time이 2, 3일때 P3 P4가 들어온다.
P3는 9 P4는 5 P1은 7이니까 P4가 그다음으로 실행된다. P4가 5만큼 실행된다.
그때 P1은 7이 남아서 P1이 실행되고 그다음 P3가 실행된다.

19p
우선순위 스케쥴링
cpu에는 우선순위가 높은것 부터 할당된다. 숫자 0이 제일 높고 숫자가 커질수록
우선순위가 낮아진다.
SJF는 우선순위 스케쥴링 기법이다. 예측되는 cpu burst time이 짧은 순으로
높은 우선순위를 가진다.
그런데 우선순위 스케쥴링은 Starvation 문제를 가진다
=> 우선순위가 낮으면 cpu로 할당이 아예 안될 수도 있다라는 현상.
=> 해결책은 오래 기다리면 기다릴수록(Aging)이라는 factor를 고려해서 
우선순위를 준다. 시간이 지남에 따라 프로세스의 우선순위가 조금씩 높아진다.

20p
우선순위 스케쥴링의 사례
그림에 나온 우선순위대로 들어온다.

21p
Round Robin(RR)
시분할 시스템에서 사용할 수 있는 특성을 가져야함.
어떤 프로세스는 어떤 정해진 시간의 양(time quantum q)만큼의 cpu 시간을 
할당 받음. 프로세스가 길든 짧든 실행할 수 있는 시간이 같게 주어짐.
이 시간이 지나면 다른 프로세스에 의해 선점(대체) 되고 레디큐로 간다.
만약 n개의 프로세스가 레디큐에 있고 time quantum이 q다.
그 어떤 프로세스도 (n-1)q 만큼 오랜 시간을 기다리지 않는다.
만약 q가 엄청 크다 => FIFO가 된다.
q가 작다 => 빨리빨리 바뀌니까 낭비하는 시간이 크다.

22p
q = 4일때 P1은 4만큼 실행되고 물러난다. P2는 3만 하면 끝이니까 작업 끝난다
P3도 3만 작업하면 끝이니까 끝난다 다시 P1이 4만큼 하고 또 쭉 실행된다.
이 RR 방식은 SJF보다 turnaround average time이 커서 안좋다. 
하지만 response time은 꽤 괜찮게 나온다.

23p
q = 12이면 프로세스 time이 10일때 한번에 실행 가능하다.
q = 6이면 한번 스위칭 된다.
q = 1이면 매번 스위칭 한다. q가 줄어들면 context switching 횟수가 많아진다.

24p
어떤 한 프로세스에 q를 1 2 3 4 5 6 7로 쭉 늘릴때 average turnaround time을
보여주는 그래프이다. q를 키운다고 해서 꼭 turnaround time이 늘어난다고 할 수 없다.
일반적으로 늘어났다가 어떤상황에서는 줄어 들 수도 있다.
프로세스의 특성에 따라 달라진다.

25p
Multilevel Queue 스케쥴링을 보자
큐를 여러개 쓴다는 말인데 레디큐가 여러개의 큐로 구성이 된다.
프로세스의 각각의 특성에 따라 특정 큐에 할당된다.
어떤거는 RR을 따르는 큐, 어떤거는 FCFS하는 큐 이런식으로 여러개 있다.
우선순위가 높은것은 foreground, 우선순위가 낮은것은 background로 할당한다.
foreground는 RR, background는 FCFS로 스케쥴링을 한다.
스케쥴링은 큐 사이에 반드시 일어나야한다.
cpu의 80퍼센트는 foreground를 RR알고리즘으로 쓰고
20퍼센트는 background를 FCFS알고리즘으로 쓴다.

26p
이 예시를 보면 우선순위가 높은 큐일수록 위쪽에 있다. 우선순위가 높은 큐에는
시스템 프로세스가 할당되어있고, 우선순위가 낮은 쪽에는 배치 프로세스 같은게
할당 되어 있다. 프로세스의 특성에 따라 우선순위에 차별을 둬서 실행을 시키겠다
레디큐를 멀티 레벨로 만들겠다 라는 것이 multilevel queue 스케쥴링이 된다.

27p
Multilevel Feedback queue
프로세스가 큐사이에 왔다갔다 할 수 있다. aging 방식이 이방법으로 쓰일 수 있다.
멀티레벨 피드백 큐 스케쥴러는 다음과 같은 파라미터로 인해 정의된다.
1. 큐가 몇개인지
2. 각 큐마다 어떤 스케쥴링 알고리즘이 적용되는지
3. 우선순위를 높이는 정책은 뭔지
4. 우선순위를 낮추는 정책은 뭔지

28p
멀티레벨 피드백 큐의 사례를 보자
Q0 는 RR이고 quantum = 8로 인해 진행, Q1는 RR, quantum = 16으로 진행
Q2는 FCFS이다
어떤 프로세스가 Q0로 도착했다. 이때 RR 방식으로 인해서 해당 프로세스가 실행된다.
그 프로세스가 8ms 안에 끝나지 않았다면, 그 프로세스는 밑으로 내려가서 
16ms 만큼의 시간안에 실행한다. 그래도 끝나지 않았다면 그 밑의 FCFS 로 가서
자신의 순서를 기다린다.

29p
Thread Scheduling을 살펴보자 프로세스 스케쥴링과는 당연히 다르다.
쓰레드에는 LWP라는 개념이 있었다. 스레드 라이브러리는 1:1 1:n과 같은 모델에 의해
실제 커널의 쓰레드와 매핑이 된다 이때 LWP라는 개념으로 매핑된다.
다시 말해 사용자 레벨이 커널 레벨로 가기전에 LWP를 통해서 동작이 되고,
사용자 프로세스 관점에서 스케쥴링은 LWP상에서 스케쥴링이 되어야하니까
하나의 프로세스 상에서 쓰레드들이 스케쥴링이 경쟁에 의해 스케쥴링이 되는
상황이 발생한다. 그래서 이것을 process contention scope(PCS) 라고 한다.
스케쥴링 경쟁이 프로세스안에서 일어나기 때문에 이렇게 부른다.
커널 레벨에서는 system contention scope(SCS) 라고 한다.

30p
사용자 레벨의 쓰레드 라이브러리는 LWP에 사용자레벨 쓰레드를 스케쥴 시킨다.
L이 LWP라고 하면 그림과 같이 스케쥴링을 시키는데 여기서 스케쥴링을 PCS라한다.
밑의 SCS를 보면 커널레벨에서 일어난다. 시스템 레벨에서 경쟁이다.
쉽게말해 프로세스 안에 여러 쓰레드가 있는데 무슨 쓰레드를 선정 할 것인지 정하고
그 선정된 쓰레드들 사이에서도 경쟁이 일어난다는 것, 각각 PCS, SCS라고 부름.

31p
LWP 개념