43p
Thread Local Storage(TLS)
프로그램에서 정의된 전역 변수는 쓰레드간에 공유하는 영역으로 표현되었다.
10p를 보면 3개의 쓰레드가 코드 데이터 파일을 공유하고 있다.
쓰레드 로컬 영역이란 뭐냐하면 쓰레드가 자기만 access할수있는 데이텨 영역이다.
그 데이터 영역을 TLS라고 한다. 그러면 그냥 지역변수 아닌가 라고 생각 할 수 있다
지역변수라고 하면 함수를 call할때 생긴다. 그런데 TLS는 전체 함수에서도 모두
볼 수 있다. static 데이터와 비슷하다고 보면 된다. 특정 쓰레드만 쓸 수 있는 영역

45p
Scheduler Activation은 사용자 쓰레드와 커널 쓰레드간의 통신이라고 이해하면 된다
이들간의 원할한 동작을 위해서는 통신이 이루어 져야 하는데 이 메커니즘을
scheduler Activation이라고 부른다. 이 그림을 보면은 사용자 쓰레드 하고
커널 쓰레드 사이에 LWP라는 중간 자료구조를 가진다. LWP는 사용자 쓰레드를
수행하기 위한 가상프로세서처럼 이해해도 된다.
upcall 커널에서 사용자로 콜을 하는 것이 보이는데 뒤에서 무슨 메커니즘인지
살펴보자

44p
LWP는 어플리케이션 관점에서보면 virtual processor로 보인다.
사용자 공간에 프로세스들이 많이 있고 유저 쓰레드가 커널 쓰레드와 연결이 되어 있다.
L = LWP로 인해 연결이 되어 있다. 커널 쓰레드는 커널 레벨의 쓰레드 스케쥴러에
의해서 실제 physical한 프로세서랑 실행이 될수 있는 형태로 바인딩 되어있다.

46p
우리가 공부하고자 하는것은 유저레벨과 커널레벨 쓰레드 사이 커뮤니케이션 
메커니즘 = scheduler Activation이다.
어떻게 이 개념이 나왔을까?
app에서 보면 user레벨 쓰레드는 당연히 안다. 하지만 커널 레벨의 상황은 모른다.
커널에서 보면 user level 쓰레드에 대한 상태정보를 효율적으로 알 수 없었다.
이런 문제가 있어서 어떤 메커니즘이 필요했는데, 이 둘 사이에 정보를 효율적으로
교환하는것이 scheduler Activation이다.
사용자 공간에서 thread가 시스템 콜을 통해서 프로세서 요청을 한다.
그러면 커널레벨에서 보면 쓰레드의 상태나 프로세서할당을 다르게 하고싶다
라는 정보를 사용자 공간에게 제공을 한다. 이것이 scheduler Activation이다.

47p
커널에서 사용자레벨로 가는것을 upcall 반대는 system call이라고 한다.
LWP 개념은 커널이 app에게 virtual processors를 제공한다라고 한다.
게다가 커널이 app에게 몇몇 이벤트를 제공하는데 이것을 upcall 이라고한다.

48p
upcall은 커널에서 유저 공간으로 정보를 제공하는데 그 정보로는
해당 processor를 써라 하는 processor 번호를 주는것과
프로세서가 preempted(선점) 되었다라는 정보라던지
아니면 블라킹이 되었다던지 언블락 되었다는지와 같은것들이 있다.

49p
여기서 scheduler Activation의 자세한 동작 예시를 보도록 하자
지금 a b 두개의 유저 쓰레드가 있다고 하자. a쓰레드가 동작을 한다
당연히 커널쪽으로 시스템 콜이 일어나야한다. 그런데 이 동작이 I/O동작이라고
하자. 그러면 너무 느려서 블라킹이 된다. 그러면 Scheduler Activation이 동작한다
그러면 커널에서는 새로운 쓰레드가 생성 되거나 쓰레드 풀에서 쓰게 해준다.
그리고 upcall 해준다. 이때의 upcall 정보는 a쓰레드가 block 되었다라는 정보다
그래서 upcall을 하면 유저레벨에서 b쓰레드가 실행이 되어라 하는 정보를 받는다

50p
조금 더 시간이 지나서 a가 unblock 되었다라고 하자. 그러면 b는 실행되다가 멈추고
다시 a를 실행시킨다 이러식으로 scheduler Activation을 통해서 유저레벨과 커널레벨이
동기화가 일어난다.

52p
windows Thread를 보면 커널레벨에 구현되어 있고
쓰레드에는 쓰레드 id 정보
레지스터 정보
스택 정보
private data storage(Thread Local Storage)를 담고있다.
이것을 쓰레드의 context라고 한다.

53p
TEB는 쓰레드의 ID, Stack, TLS 같은 정보들이 담겨있다.

55p
리눅스 쓰레드를 보자
리눅스에서는 태스크나 쓰레드나 구분없이 사용하고 있다.
프로세스나 thread를 만들때 clone이라는 시스템 콜을 사용한다.

