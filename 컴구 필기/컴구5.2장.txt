27p
16메가비트다 라고 하면 여러가지 조합으로 구성할 수 있다.
16비트 출력을 한꺼번에 내면 라인 1메가짜리의 메모리로 구성할 수 있다.

28p
실제 16메가비트 메모리가 어떻게 구성되는지 알아보자.
맨 오른쪽 밑을 보면 최종 출력 비트가 4비트라는것을 알 수 있다.
Refresh Counter를 쓴것을 보아 DRAM이다.
주소의 크기를 보니까 11비트다. 총 11비트니까 2K까지 표현이 가능 하다.
행을 2K 열을 2K 만큼 선택하니까 총 크기는 2K * 2K = 4메가가 된다.
총 라인이 4메가 개가 있는데 한 라인에 4비트니까 총 크기는 16메가 비트가 된다.
버스를 공유하기 때문에 한번은 ROW addr로 보내고 한번은 Colum addr로 보낸다
WE는 write enable이다. WE가 low일때 활성화 된다. OE는 output enable이다. 마찬가지로 low일때 활성화 된다.
출력버퍼와 입력버퍼가 데이터 버스를 공유하고 있다. 한번은 출력이고 출력됨과 동시에 refresh하기 위해 입력된다.
먹스는 refresh 주소값을 주기위해 사용한다.

29p
오래된 패키징의 형태이다.

30p
메모리를 어떻게 구성할지 더 자세히 살펴보자.
18비트짜리를 9비트 9비트로 나누면
row 512중에 하나선택 column 512중에 하나선택 이런식으로 만들수 있다.
총 칩의 갯수는 8개 이므로 비트 하나씩을 출력해 총 8비트를 출력할 수 있다.
하나의 칩은 512 * 512 이므로 256K비트를 저장할 수 있다.
8개의 칩을 뭉쳤으므로 256K byte가 된다.

31p
이전의 256k를 모듈식으로 구성해서 4개 사용해서 1메가바이트의 용량을 가지게 할 수 있다.
이 4개중 하나를 선택할수 있는 Group select가 있다.
그래서 MAR은 row + column + group select까지 해야하니까 20비트가 필요하다. 2의 18이 256Kbyte니까 2의 20은 1Mbyte 맞다.

32p
메모리란 주위의 환경(방사선, 주위의 전기적인 불안정성)에 따라 오류가 생길수 있다.
이런 오류를 Soft Error라고 한다. Random하게 발생되고, non-destructive 반도체가 파괴가 되지 않고 일시적인 현상으로 데이터가 파괴된다.
Hard Failure는 영구적인 결함이 생긴 것으로 어쩔 수 없다.
여기서 Soft Error가 생겼을때 Error을 자동으로 잡아서 고쳐주는 기법들이 있다. 이게 Error correction code라고 한다.
가장 유명한 것이 Hamming error correction code이다.

33p
기본적인 Error Correcting 구조이다.
일단 M비트짜리 데이터가 메모리에 저장되고 있다. 여기서 딱 M비트만 저장되는 것이 아니라 어떤 함수 f에 의하여 이 데이터를 연산하여
추가로 K비트를 더 저장시켜 놓는다. 만약 데이터에 오류가 생긴지 확인하려면 M비트 짜리 저장된 데이터를 동일한 함수 f에 넣고 돌려서
K비트짜리 데이터를 만들고 아까 저장시켜놓은 K비트짜리 데이터와 비교하여 같으면 Error가 없다고 결론낸다. 둘중에 어느 하나라도 다르면
Error가 발생한 것이다.
에러가 발생했을때 에러를 고칠수 있으면 고쳐서 쓰고 아니면 Error signal을 내보낸다.
중요한것은 데이터 뿐만아니라 어떠한 로직에 의해 변환한 데이터를 같이 저장하는 방식이다.

34p, 35p
Hamming Code를 살펴보자.
A에 해당되는 것은 1의 갯수를 짝수로 만드는 로직을 가지고 Hamming Code를 만든다.
따라서 추가되어야 할 비트를 1을 쓴다.
B는 현재 1의 갯수가 짝수니까 0이 추가
C도 0이 추가된다. 이때 35p 그림과 같이 어떤 이유로 의해 데이터가 손상된다.
그러면 A와 C의 공통된 비트가 문제가 있다고 판단하고, B는 문제가 없다고 판단한다.
A와 C의 공통 - B 의 부분을 Correction한다.

36p
총 M비트가 있을때 추가하는 비트=K 는 총 얼마가 되어야 하는지를 보면
Step1의 수식을 만족 시켜야한다.
Error를 고치는 logic을 보면 Syndrome이라는 개념이 나온다. Syndrome이라는 것은 어떤 현상이 드러나는 형태이다.
여기서 Syndrome을 계산한다 라고 하면 이전 코드비트와 새로운 코드비트를 XOR한 것을 말한다.
Syndrome이 0이면 에러가 없고 1이면 Error가 있다고 말한다.

37p
M이 8인 경우, K가 4인 경우 수식을 만족한다. 여기서 K의 비트를 하나 더 추가하면
Single Error Correction 할 수 있고 Double-Error는 Detection할 수 있다.
데이터 비트가 커지면 커질수록 간접비는 가파르게 낮아진다.

38p
single bit를 어떻게 고칠것이냐를 보자 8비트가 들어왔다고 하자. 8비트일때는 공식에 의해서 체크비트가 4개이다.
그림을 보면 bit position이 1 2 4 8일 때 이진수에서 1이 하나밖에 존재하지 않는다. 이것들을 체크비트로 둔다,
체크비트는 1 2 4 8 이렇게두고 나머지 비트들이 8개 생길때까지 진행한다
그러면 총 12비트가 된다. 나머지 비트들 중에 체크비트의 1의 자리에 1이 있는 비트들을 전부 XOR시킨다.
그러면 체크비트의 값이 나온다. 1 2 4 8 저거는 그냥 체크비트가 있어야할 위치를 의미한다.


40p
만약에 Example처럼 인풋데이터가 8비트가 들어오면 체크비트는 공식에 의해서 4비트 이상 되어야 한다.
맨 오른쪽이 D1 맨 왼쪽이 D8이라고 했을때 결과는 c1 = D1 D2 D4 D5 D7을 XOR 시킨 것 이므로 1이 되고.. 이런식으로 체크비트를 만든다.
체크비트를 위치에 맞게 끼워 넣는다. 이렇게 12비트를 저장한다.
만약 6번째 0이라는 데이터가 오류가 났다라고 생각해보자. 그러면 0이 1로 바뀌게된다.
다시 M비트를 위의 로직에 따라서 계산(XOR) 하면 체크비트가 0111에서 0001이 된다.
둘을 XOR하면 == syndrome 0110 이된다 이게 12비트중에 6비트 포지션에 문제가 있다는 말이다. 그래서 6번째 비트를 바꿔야한다.

42p
두비트가 동시에 Error가 나면 어떻게 되는지 보여주는 그림이다.
(c)에서 corection 하려면 더욱 많은 에러가 발생된다.
그래서 왼쪽 아래에 비트를 하나 더 추가해서 1을 짝수개로 만든다.
그러면 (e)에서 모순이 발생하여 최소한 두비트 이상이 에러가 났구나 라고 Detection만 할 수 있다.
