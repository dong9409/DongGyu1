컴퓨터 구조 2장

3p
고성능화가 진행중이다.

파이프라이닝: 
프로세서 내에서 데이터를 지속적으로 패치 하여 처리하고 
명령어도 어느 순간의 하나의 명령어만 해석하거나 실행하거나 결과를 쓰는게 아니라
동시에 여러개의 명령어를 어떤 명령어는 fetch 하고 어떤 명령어는 decode 하고 이런식으로 
프로세서가 설계되는 것을 파이프라이닝이라고한다.

Branch prediction:
프로세서가 어디로 점프할지 예상해서 그쪽에 있는 명령어를 미리 가지고 와서 실행한다. 

Superscalar execution:
일반 연산은 스칼라 연산 배열 연산과 같은것을 벡터 연산이라고 한다.
스칼라 연산을 하는 연산기가 여러개라는 뜻 명령어를 여러개를 실행시킬 수 있다.

Data flow analysis:
데이터나 명령의 의존성을 분석해서 최적의 스케쥴링을 찾는 기법이다.

Speculative execution:
정확한 정보에 기반을 두지 않고 추측에 기반을 두고 다음번 데이터를 패치해온다.

4p
프로세서와 메모리의 속도문제, 정수연산과 플로팅포인트의 연산속도 문제 등 
일부분은 빠르지만 나머지는 느린 밸런스 문제가 발생. => 전체적인 성능은 느린녀석에 의존
ex)메모리: wider rather than deeper, wider는 한번에 읽을수 있는 데이터의 용량, deeper 는 32비트 16비트 차이
한번에 읽을수 있는 용량을 키우는 것이 성능 향상에 좋다.

ex)cpu 보다 메모리가 더 느리기 때문에 메모리에 접근하는 횟수 자체를 줄이면 성능이 향상된다=>캐시메모리

5p
입출력 디바이스의 입출력 속도.

6p
고성능화를 위해서는 
1.shrinking logic gate size
반도체의 크기자체를 작게 만드는것, 많은 트랜지스터를 집적하는것

2.캐쉬 사용.
캐쉬메모리 사용

3.고성능 명령으로 바꾸거나, 병렬형 컴퓨터로 바꾼다.
병렬형 컴퓨터 => multi core 프로세서, 파이프라인 등..

7p
클락속도=frequency 를 계속 높이고 logic Density를 계속 키우면 성능은 올라가지만
Power 문제가 생긴다. => 열이 많이 난다.

9p
멀티코어 => 코어를 여러개 사용한다.
코어가 여러개라고 무조건 좋은게 아니고, 소프트웨어 또한 병렬 처리가 가능해야 효과가 좋다.

10p
암달의 법칙 => 병렬처리와 관련된 법칙
어떤 코드중에서 f만큼의 비율이 병렬처리 가능하다고 하고, N개의 프로세서가 동작 가능하다고 하면
speedup 이라는 성능 측정치는 1/(1-f+f/N)이 된다. 여기서 N이 무한으로 가면 1/(1-f)가 최대 speedup이 된다.
1-f가 적으면 적을수록 병렬처리에 좋다.

13p
fT는 병렬처리 가능 (1-f)T는 병렬처리 불가능 부분이다. 
절대 병렬로 쪼개질 수 없는 problem = inherently serial problems

15p
Little's Law
L = 람다 * W
==> 시스템에서의 평균 아이템 수 = 얼마만큼 도착하는가 * 얼마만큼 평균적으로 오래 기다리느냐

17p
시스템 구성요소 별 성능에 영향을 주는 인자.

18p
기하평균 = 값의 곱을 사용해서 어떤 경향을 얻을 때 쓴다.

19p
숫자 샘플 별 평균의 비교.

20p
조화평균, 기하평균을 사용해서 성능을 평가할 수 있음.

22p
성능 비교는 상대적이므로, 비교시 마다 다르면 신뢰성 떨어짐. 따라서 GM으로 비교하는것이 좋음.

24p
벤치마킹 => 이론적인 평가 말고 실제로 프로그램을 돌려서 성능 측정.
