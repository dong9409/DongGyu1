3장 PART 2

사용자 프로그램이 실행 되다가 i 주소까지 실행 된다.
i 주소까지 실행된 직후에 인터럽트가 발생한다. 여기서 프로그램 카운터는 i+1의 주소값을 가지고 있다.
하지만 인터럽트가 발생되면 프로그램 카운터는 interrupt handler 의 주소값으로 바뀌어야 한다.
그러면 interrupt handler 의 코드를 다 실행하고 나서, 다시 프로그램 카운터는 i+1의 주소값을 가져야 한다.
이러면 사용자 프로그램은 다른 걸 할 필요가 없다. os와 cpu가 알아서 해준다.


이전의 싸이클을 보면 인터럽트를 고려하지 않았다.
하지만 인터럽트가 enabled된 경우 fetch, execute, interrupt check추가된 싸이클을 고려해야한다.


a는 인터럽트가 없는경우, b는 인터럽트가 있는 경우 
a의 검은 부분은 cpu가 실행되지 않는 부분을 나타낸다.
이 검은 부분동안 cpu는 기다려야한다.
여기서 인터럽트는 short I/O wait를 가정한다.
인터럽트를 이용하면 더 빠른시간내에 작업을 다 처리한다.


long I/O wait를 표현한 그림이다. 하나의 프린트가 다 끝나지 않았는데
다시 프린트 인터럽트가 들어오면 먼저 들어간 인터럽트가 실행될 때 까지 기다려야한다
따라서 2번 코드 다음에 cpu가 대기하는 시간이 나타난다. 이 상황은 multiple 한 인터럽트를 처리하지 못하는 경우에 나타난다.


instruction cycle 아래쪽은 cpu 내부 윗쪽은 cpu 외부에서 일어나는 작업이다.
instruction을 가지고와서, decoding 되고 operand가 필요한지 체크해서 가지고 오고 operation을 한다.
그 결과를 위한 주소값을 계산하고 결과값을 store한다. 여기서 인터럽트를 체크하고 인터럽트가 없으면
다시 fetch하고 인터럽트가 있으면 인터럽트를 실행한다.


Multiple한 인터럽트가 발생했을때 처리하는 방법이다.
위의 그림은 sequential하게 인터럽트를 기다렸다가 처리하는 방식이다.
밑의 그림은 첫번째 인터럽트가 발생하고, 두번째 인터럽트가 발생하면
첫번째 인터럽트를 중지하고 두번째 인터럽트를 처리하고 다시 첫번째 인터럽트를 처리하고 유저 프로그램으로 돌아온다
Nested Interrupt라고 한다.


Multiple Interrupt 소요시간은 그냥 다 더하면 된다.


I/O 모듈은 프로세서하고 직접적으로 데이터를 교환하는 것을 말한다.
I/O 모듈은 실제 입출력 디바이스를 말하는 것이 아니라, 입출력 디바이스와 cpu사이의 매개체 역할을 하는 것을 말한다.
예를들어 cpu의 신호를 적절한 아날로그 신호로 바꿔 주거나 하는것을 말한다.


프로세서는 I/O 모듈과 통신하고 I/O 디바이스도 I/O 모듈과 통신한다.
원래 데이터가 들어오려면 I/O 모듈 지나서 프로세서 지나서 메모리로 가는데 I/O가 메모리와 직접적으로 통신을
해야하는 상황이 생긴다. 이 상황 때문에 DMA가 필요하다.


메모리 I/O, Module, Cpu 의 입출력을 간단히 나타낸 그림이다.
메모리에 데이터를 쓰려면 write signal 읽으려면 read signal이 필요하다. 어디에서 작업을 할건지 알기 위해서 address 가 필요하고 data도 당연히 필요하다. 읽을경우 읽는 데이터를 출력하는 포트가 필요하다.
I/O 모듈도 외부로부터 데이터를 입력, 출력하는 모드가 필요하니까 read, write가 필요하고
어느 I/O 디바이스냐를 선택하기 위해서 Address가 필요하다.  cpu 혹은 메모리로 부터 오는 데이터를 Internal Data라고 하고 외부로 부터 오는 데이터를 External Data라고 한다.  cpu에게 알려주기 위해서 인터럽트 signal을 출력하는 포트도 존재한다. 
CPU 는 명령을받고 인터럽트 signal을 받는다 이것을 해서을 해서 control signal을 발생 시킨다. 그리고 계산된 데이터를 출력한다. Cpu는 주소값을 출력하는데, 이 주소값은 메모리의 입력으로 쓰이거나 입출력 모듈의 입력으로 쓰인다.


메모리구조 설명..


입출력 모듈의 extrenal data라는 것은 external device와 주고받는 데이터를 말함. 제일 중요한건 인터럽트 signal을 발생시킨다는 것.


프로세서는 명령어를 받아들이고 해석해서 control signal을 발생 시키고 주소를 생성한다. 모든것을 다 제어한다.


프로세서, 메모리, 입출력과의 interconnection 데이터 패스가 필요하다는 것을 보여준다.
보통 항상 프로세서를 통해서 데이터가 이동하는데, 맨 오른쪽의 그림은 DMA라는 개념으로, 프로세서를 통하지 않고 메모리에 데이터를 읽고쓴다.


데이터 패스는 병렬구조로도 만들 수 있고 여러가지로 만들 수 있다. 버스는 딱 두개만 통신하는게 아니라 여러개의 디바이스와 함께 통신할수 있다. 그리고 하나의 선이 아닌 여러개의 선으로 일반적으로 연결된다. 최근의 컴퓨터는 다양한 연결방식이 나오고 있다. 버스에는 느린 버스와 빠른 버스가 있는데, 프로세서와 메모리 버스 같은것들은 빠른 버스를 쓴다.
프로세서와 캐쉬는 가장 빠른 로컬 버스로 연결하고, 프로세서와 메모리 사이에는 중간 빠르기의 시스템 버스로 연결하고 제일 느린 Expansion Bus가 있다. 이렇게 다양한 종류의 버스로 구성되어 있다.


Data Bus는 데이터를 전송하는 path way라고 보면 된다. 32, 64, 128bit data bus가 있다. 한번에 병렬적으로 전송할수 있는 데이터 수를 나타내고, 데이터 버스의 폭은 시스템의 중요한 성능 평가 척도가 된다. 대부분 32bit 프로세서는 32bit 데이터 버스를 쓴다.


Address Bus, Control Bus는 그냥 한번 읽어보자.


Bus의 구조는 control Line, 주소 라인, 데이터 라인으로 되어있다. 이 그림은 동일한 버스를 공유하는 아주 초기의 모습을 나타낸다. 위의 속도 위계를 가지는 버스 구조와는 다르다.


a는 전통적인 버스 구조를 나타내고, b는 고성능 구조를 나타낸다. 둘의 차이점은 SCSI나 네트워크는 고속 입출력 장치인데 모뎀이나 시리얼은 느린 입출력 장치이다. 그래서 b의 경우에는 SCSI나 네트워크에서 더 빠른 버스를 사용함으로 더 알맞게 계층화 시킨다.


버스는 여러가지 요소에 따라 다르게 디자인 되는데, 이 요소중 타이밍이 중요하기 떄문에 보도록 한다.
Synchronous는 동기화이다. 어떤 기준에 동기를 맞춘다. 그림에 보이는 여러가지중 Clock에 따라 동기화 되어 있다.
Clock이라는 기준 signal에 의하여 다 맞추어져 있다. 하나의 예로 Read Cycle이 어떻게 그림과 같이 나오는지 보자.
Read Cycle이라는 것은 프로세서가 메모리의 특정 위치를 읽는 사이클이다. 특정 메모리의 위치에 해당하는 값을 읽어야 되니까 주소가 필요하다. 위의 주소를 cpu가 생성하는데 32, 64비트 일때 주소를 안정화 하는데 어느정도의 딜레이가 필요하므로 주소값이 살짝 밀린다. address enable은 주소값이 떴으니까 address를 enable 시킨다. 이제 주소를 활용할 수 있다. 이때 프로세스는 이제 메모리를 읽는다고 Read signal을 보낸다. 메모리 입장에서는 Addrss가 Enable 됐다는 신호를 받았고, stable한 address가 있으며, cpu로 부터 read signal을 받았으니까 valid data in 으로 데이터를 출력한다. cpu 입장에서 봤기 때문에 out이 아닌 data in이라고 한다. data out도 비슷하게 동작한다.


Asynchronous는 비동기이다. clock이 없다. 어떤 한 signal의 결과에 의해서 두번 째 signal이 실행된다.


타이밍 다이어그램이 나왔으므로 매우 중요하다. G80 프로세서가 롬의 데이터를 읽는 예시를 들어보자.
그림을 보면 address를 프로세서가 생성해서 롬에 집어넣는다. 거기에 있는 데이터를 출력한다. MREQ는 negative이므로 falling edge에서 동작한다. address를 약간의 딜레이를 거쳐 버스에 싣는다. 그리고 momory를 request하는 신호를 보낸다
나머지는 그림을 보면서 이해한다.


다음은 rom이 아닌 ram에 data를 write하는 경우를 살펴본다. 메모리의 주소가 그림과 같다고 할때 주소는  A14가 항상 1이 되어야 한다. 따라서 MREQ와 A14가 and가 되어서 ram을 enable 시킨다. g80의 address에서 a14를 빼서, enable로 쓰고 a13까지가 실제 메모리의 주소가 지정 된다. 해당되는 주소값을 버스에 싣고, 데이터를 버스에 싣는다. 그다음 write signal을 보낸다. 여기에는 /MREQ 이기 때문에 앞의 MREQ와 모양이 다르다.


요즘에는 공유된 버스를 쓰는게 아니라, point to point interconnect를 하는 버스를 쓴다. 버스를 공유 하게 되면, control signal끼리의 간섭 때문에 딜레이나 왜곡이 많이 생긴다.


Quick Path interconnect라는 기술은 계층을 가지는 프로토콜 구조를 가진다. physical level은 phit이라는 이름을 가지면서 총 20비트짜리 width를 가진다. Link layer는 fow 컨트롤과 reliable 해주는 구조를 가진다. 라우팅은 패킷형태로 여러 길을 찾아주는 기능을 한다. 프로토콜은 data에 대한 packet 레벨로 특성을 제시해주는 것이다.????


Qpi Mutilane Distribution 다 섞여 있는거 분리 하는걸 라우팅이라고 해서 따로 전송한다. => 라우팅 길찾기


PCI도 거의 유사한 형태를 가진다. layer형태를 가진다. 공유된 버스 형태가 아니라 레이어로 구성이 되어서 안정적이고 여러 디바이스를 연결 시켜주는 형태로 발전이 되었다.