4.2장

25p
캐시의 동작
1. 우선 CPU가 특정 메모리에 있는 정보를 읽고자하면 그 메모리 주소를 발생시킨다.
2. 캐시를 체크한다. 해당되는 데이터가 있는지.
3. 존재하면 가지고온다.
4. 없으면 메인메모리로부터 데이터를 가져오고 캐시에도 저장한다.

26p
왼쪽에 있는게 캐시고 오른쪽이 메인메모리다.
캐시에 한칸만 가지고 오는게 아니라, 참조의 지역성을 이용하기위해 특정 블럭 사이즈만큼의 데이터를 가지고 온다.

28p
캐시를 디자인할때 필요한것.
1. 캐시의 사이즈
2. 매핑함수 => 메인메모리의 데이터나 명령이 있는 블럭이 캐시의 어디에 저장이 될것이냐에 대한 문제.
3. replacement => 메인메모리에서 새로 가지고 오면 어떻게 캐시의 데이터를 대체할 것이냐 에 대한 문제
4. Write Policy
5. 블락 사이즈 어느정도로 할것인가
6. 캐시를 몇개 쓸것인가?

29p
SIZE에 관한 문제
캐시는 비싸다, 캐시는 빠르다, 이 두 요소의 optimal을 찾는다

30p
캐시를 어디에 둘것이냐? 프로세서와 MMU 사이? 혹은 MMU 뒤쪽에 둘것이냐
프로세서와 MMU사이 즉 virtual address에 캐시를 두면 Logical cache라고 한다.
Logical cache에서는 프로세서가 캐시를 직접적으로 접근 할 수 있다.
장점은 빠르다. 해당되는 데이터를 찾기 위해서 주소변환을 굳이 안해도 돼서.
단점은 프로세서가 여러개일때도 같은 가상 주소를 쓰기 때문에 replacement가 될 수 있다. flushing 시켜야한다.

32p
MMU =  virtual 주소를 physical 주소로 바꿔줌
가상 주소를 물리 주소로 바꾸기 전에, 즉 프로세서에서 바로 나온 주소에 캐시를 둘것이냐
아니면 물리 주소로 바뀐 뒤에 캐시를 둘것이냐 에 대한 문제가 생긴다.
가상주소 기반 인지 물리 주소 기반인지에 대한 문제, 각각 장단점이 있다.

33p
기본적인 캐시 구조
프로세서에서 주소가 발생되면, 이 주소는 캐시쪽으로도 들어가고 메모리로도 들어간다.
캐시를 먼저 살펴보고 miss되면 메인메모리에서 데이터를 캐시로 가져옴과 동시에 프로세서에서 쓴다.

34p
캐시 주소에 따라 Logical Physical으로 나누고 매핑하는 방식에 따라서도 다르다....

35p
여러가지 컴퓨터들의 캐시 사이즈, 별로 안크다.

36p
매핑 하는 방법들
메인메모리에 해당하는 블럭을 캐시의 어디에 매핑 할꺼냐를 정하는 것
Direct, Associative, Set Associative의 세가지 방법이 존재한다.

37p
매핑 방법을 논하기 전에 일반적으로 캐시의 크기는 64킬로바이트라고 가정,
블락 사이즈 4바이트라고 가정,
캐시의 총용량이 64k이고 한 라인이 4니까 총 라인의 수는 64k/4 = 16k의 라인개수를 가진다.
하나의 라인은 하나의 블럭크기와 같다. 블럭이 통채로 라인으로 들어오니까.
메인메모리는 16메가바이트라고 하면 16메가는 2의24승의 크기이기 때문에 전부 다 표현하려면 24bit가 필요하다.
따라서 24bit 짜리의 공간으로 표현된다.

38p
Direct Mapping
블럭크기는 메모리 한칸에 해당하도록 1대1로 가정하자.
i = j % m 의 공식을 이용해서 j라는 메인메모리의 주소를 m으로 나눠서 (여기서 m은 캐시라인의 개수) 그것을 캐시의 주소로 쓴다. 
예를들어 12라는 주소를 캐시에 저장하려면 12 mod 8 해서 캐시의 4번째 라인에 저장한다.
메인메모리의 20번지는 캐시의 4번째 라인에 저장된다. 12와 20번지가 같은곳을 씀으로 20으로 replacement 시킨다.

39p
cpu가 1번지를 읽으면 캐시에 1번지 데이터를 저장하고 m+1번지를 읽으면 캐시 미스가 발생하고 m+1번지의 데이터로 replacemnet 시킨다.

40p
각각의 메인메모리 블락은 오직 하나의 캐시 라인에 들어갈 수 있다. w는 블럭 하나에서 몇번째 칸이냐를 말하는 거고,
나머지는 해당되는 메인메모리 주소가 캐시의 몇번째 라인에 해당되는지를 표현한다. 태그는 실제 데이터가 그곳에 있느냐를 말한다.

42p
왼쪽이 메인메모리고 오른쪽이 캐시이다. 
다이렉트 맵핑은 메모리의 주소가 지정되면 자기가 갈수있는 곳이 지정이 된다. 따라서 반드시 충돌이 일어날수 밖에 없다.

43p
CPU에서 주소를 주면 
첫번째 캐시의 라인을 체크한다.
두번째 실제로 그 데이터가 맞는지 태그로 체크한다. 태그 두개가 같으면 hit이다.
세번쨰 블럭중에 몇번째 칸이 데이터인지 보고 가져온다.
만약에 미스가 나면 캐시에 업데이트하고 cpu에서 쓴다.


예시에서 맨 오른쪽 비트 두개는 13, 57, 92, 46과 같이 블럭에서 몇번째에 존재하는지 찾는 역할을 한다(2글자가 1바이트니까)
그리고 캐시의 몇번째 라인에 위치하는지 정하기 위해서 14비트를 썼는데 캐시가 총 16k line 이기 때문에 2의 4 + 10 해서 14승이니까
14비트가 필요하다 여기서 라인수는 캐시의 사이즈를 블록의 사이즈로 나눈 것이다. 그리고 남은 태그값은 실제로 그값이 맞는지 체크할때
쓴다.

45p
Direct Mapping의 장단점
장점: 매우 간단하다.
단점: 데이터가 들어갈수 있는자리가 딱 정해져있다. => 캐시가 비워져있어도 다른칸에 못들어가서 비효율 적이다.
극단적으로 동일한 라인에 들어가는 블락 두개를 계속해서 참조해야할때 캐시미스가 계속 발생할 수 있다.

47p
이러한 Direct Mapping 방식이 너무 flexible하지 않아서 Victim 캐시를 이용한다.
Direct Mapped된 캐시가 있고 Victim 캐시가 있는데, 위와같은 극단적인 경우에서 Replace 될때 victim캐시로 옮겨서 재사용 할수 있게함.
Direct Mapping 캐시의 단점을 극복하는 방법중 하나이다.