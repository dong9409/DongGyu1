4.2장

25p
캐시의 동작
1. 우선 CPU가 특정 메모리에 있는 정보를 읽고자하면 그 메모리 주소를 발생시킨다.
2. 캐시를 체크한다. 해당되는 데이터가 있는지.
3. 존재하면 가지고온다.
4. 없으면 메인메모리로부터 데이터를 가져오고 캐시에도 저장한다.

26p
왼쪽에 있는게 캐시고 오른쪽이 메인메모리다.
캐시에 한칸만 가지고 오는게 아니라, 참조의 지역성을 이용하기위해 특정 블럭 사이즈만큼의 데이터를 가지고 온다.

28p
캐시를 디자인할때 필요한것.
1. 캐시의 사이즈
2. 매핑함수 => 메인메모리의 데이터나 명령이 있는 블럭이 캐시의 어디에 저장이 될것이냐에 대한 문제.
3. replacement => 메인메모리에서 새로 가지고 오면 어떻게 캐시의 데이터를 대체할 것이냐 에 대한 문제
4. Write Policy
5. 블락 사이즈 어느정도로 할것인가
6. 캐시를 몇개 쓸것인가?

29p
SIZE에 관한 문제
캐시는 비싸다, 캐시는 빠르다, 이 두 요소의 optimal을 찾는다

30p
캐시를 어디에 둘것이냐? 프로세서와 MMU 사이? 혹은 MMU 뒤쪽에 둘것이냐
프로세서와 MMU사이 즉 virtual address에 캐시를 두면 Logical cache라고 한다.
Logical cache에서는 프로세서가 캐시를 직접적으로 접근 할 수 있다.
장점은 빠르다. 해당되는 데이터를 찾기 위해서 주소변환을 굳이 안해도 돼서.
단점은 프로세서가 여러개일때도 같은 가상 주소를 쓰기 때문에 replacement가 될 수 있다. flushing 시켜야한다.

32p
MMU =  virtual 주소를 physical 주소로 바꿔줌
가상 주소를 물리 주소로 바꾸기 전에, 즉 프로세서에서 바로 나온 주소에 캐시를 둘것이냐
아니면 물리 주소로 바뀐 뒤에 캐시를 둘것이냐 에 대한 문제가 생긴다.
가상주소 기반 인지 물리 주소 기반인지에 대한 문제, 각각 장단점이 있다.

33p
기본적인 캐시 구조
프로세서에서 주소가 발생되면, 이 주소는 캐시쪽으로도 들어가고 메모리로도 들어간다.
캐시를 먼저 살펴보고 miss되면 메인메모리에서 데이터를 캐시로 가져옴과 동시에 프로세서에서 쓴다.

34p
캐시 주소에 따라 Logical Physical으로 나누고 매핑하는 방식에 따라서도 다르다....

35p
여러가지 컴퓨터들의 캐시 사이즈, 별로 안크다.

36p
매핑 하는 방법들
메인메모리에 해당하는 블럭을 캐시의 어디에 매핑 할꺼냐를 정하는 것
Direct, Associative, Set Associative의 세가지 방법이 존재한다.

37p
매핑 방법을 논하기 전에 일반적으로 캐시의 크기는 64킬로바이트라고 가정,
블락 사이즈 4바이트라고 가정,
캐시의 총용량이 64k이고 한 라인이 4니까 총 라인의 수는 64k/4 = 16k의 라인개수를 가진다.
하나의 라인은 하나의 블럭크기와 같다. 블럭이 통채로 라인으로 들어오니까.
메인메모리는 16메가바이트라고 하면 16메가는 2의24승의 크기이기 때문에 전부 다 표현하려면 24bit가 필요하다.
따라서 24bit 짜리의 공간으로 표현된다.

38p
Direct Mapping
블럭크기는 메모리 한칸에 해당하도록 1대1로 가정하자.
i = j % m 의 공식을 이용해서 j라는 메인메모리의 주소를 m으로 나눠서 (여기서 m은 캐시라인의 개수) 그것을 캐시의 주소로 쓴다. 예를들어 12라는 주소를 캐시에 저장하려면 12 mod 8 해서 캐시의 4번째 라인에 저장한다.
