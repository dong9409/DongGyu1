programmed I/O는 cpu가 다 제어한다
cpu 관점에서 보면 메모리에 데이터를 입출력 하는것이나 입출력 디바이스에 데이터를 입출력 하는 것이나 동일하게 본다.
특정 메모리의 위치에 데이터를 읽고 쓰려면 address를 쓰는데 이것과 동일하게 입출력 디바이스도 address를 쓴다.


Memory mapped I/O
디바이스들이 cpu가 관리하고 바라보는 주소공간의 하나의 어드레스에 매핑 되어 있다는 뜻이다.
특정 메모리 주소는 특정 디바이스를 가리킨다. 메모리를 access 하는 방식이나 디바이스를 access하는 방식이나 동일하다.


Isolated I/O
메모리와 동일한 공간의 주소공간이 아니라 입출력을 위한 특별한 명령어가 있고, 입출력을 위한 특정 주소가 따로 있다.


Memory mapped의 작동방식
516번지는 키보드 입력 데이터 레지스터 517번지는 키보드 입력 상태, 제어를 위한 레지스터 라고보자.
이 레지스터는 메모리의 특정 주소다 라고 생각해도 된다.
AC에 1을 쓰고 517번지에 1을 써라 => start비트가 1이 된다.
맨 왼쪽 비트가 0이면 계속 기다리고 1이면 516번지의 값을 읽어라.


Isolated I/O의 작동방식
입출력 포트 5번은 키보드의 입력과 제어를 위한 포트라고 가정
Load I/O     	5    ==   입출력 포트 5번을 쓰겠다라는 의미,
Test I/O	5    ==   포트 5번에 어떤 값이 있는지 체크하겠다, status를 읽겠다.
준비 안돼있으면 반복시행한다. 준비되면 데이터를 load한다.
=> 입출력을 위해서 특정 명령어를 사용하고, 포트넘버가 존재한다. 메모리와 별도로 존재한다.


memory mapped는 메모리access코드나 입출력 access코드나 같아서 단순함.
하지만 메모리의 한 부분을 입출력 전용으로 써야 하기 대문에 공간이 줄어든다.


Interrupt Driven I/O
입출력의 동작을 위하여 Interrupt를 사용한다.


24p
입출력 모듈의 관점 읽어보기

cpu 관점 save context = 하던일 저장. 
인터럽트 보러감.


인터럽트 전반적으로 동작하는 방식
맨 위쪽에는 스택, 밑에는 인터럽트 코드, 밑에는 유저 프로그램 이다.
주소N을 수행하고 있을때, 이때의 PC = N+1 이때 스택포인터는 T
이때 인터럽트가 발생하면 현재 프로세서의 값들(레지스터, 프로그램 카운터)는 스택에 저장이된다.
스택은 거꾸로 성장하니까 T 에서 T-M까지 되고 스택포인터는 T-M이 된다.
프로그램 카운터는 이제 새로운 Y라는 주소값을 받는데 이건 인터럽트 코드의 주소다.
그리고 인터럽트 서비스 루틴이 실행된다. Y+L까지 다 실행하고 리턴한다.
그러면 원래 cpu가 하던걸 복구 시켜야한다. 스택에서 PC 값이랑 레지스터 값을 읽어와서 복구시키고 스택은 다시 작아져서
스택포인터는 T가 된다. 그리고 다시 N+1의 주소로 넘어가서 실행된다.
